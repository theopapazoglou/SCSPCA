import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import roc_auc_score, confusion_matrix, accuracy_score, precision_score, recall_score, f1_score
from scipy.linalg import eigh

# For the classification analysis, reduce SCPCA's and SSPCA's iterations to 1000.

# Accelerated SPCA using HSIC and CSPCA

def spca_hsic(X, Y, K, q, epsilon= 1e-6):
    n = K.shape[0]
    K_reg = K + epsilon * np.eye(n)
    Delta = linalg.cholesky(K_reg, lower=True)  
    psi = X.T @ Delta  
    U, s, Vt = svd(psi, full_matrices=False)
    Sigma = onp.diag(s)
    U_d = U[:, :q]
    Sigma_d = Sigma[:q, :q]
    V_d = Vt.T[:, :q]  
    U_hat = psi @ V_d @ linalg.inv(Sigma_d)  
    eigenvalues = s[:q]**2 
    return {'W': U_hat, 'singular_values': eigenvalues}


def cspca(X, Y, q, p, m, lambda_):
    XtX = X.T @ X
    C = X.T @ delta_kernel(Y) @ X + lambda_ * XtX
    indices = onp.random.choice(p, size=m, replace=False)
    C_nm = C[:, indices]  
    C_mm = C[indices, :][:, indices]  
    eigenvalues, U_m = linalg.eigh(C_mm)  
    sorted_indices = onp.argsort(eigenvalues)[::-1]
    eigenvalues = eigenvalues[sorted_indices]
    U_m = U_m[:, sorted_indices]
    Lambda_m = onp.diag(eigenvalues)
    Lambda_m_inv_sqrt = onp.diag(1.0 / onp.sqrt(onp.maximum(eigenvalues, 1e-6)))
    U_n = C_nm @ U_m @ Lambda_m_inv_sqrt  
    C_mm_inv = pinv(C_mm)  
    C_approx = C_nm @ C_mm_inv @ C_nm.T
    W = U_n[:, :q]
    W, _ = qr(W, mode='economic') 
    return {'W': W, 'eigenvalues': eigenvalues[:q]}



y = pd.read_csv("actual.csv")
data_2 = pd.read_csv("data_set_ALL_AML_independent.csv")
data_3 = pd.read_csv("data_set_ALL_AML_train.csv")
print(y.shape)
print(data_2.shape)
print(data_3.shape)

Y = y.replace({'ALL':0,'AML':1})
labels = ['ALL', 'AML']

train_to_keep = [col for col in data_3.columns if "call" not in col]
test_to_keep = [col for col in data_2.columns if "call" not in col]

X_train_tr = data_3[train_to_keep]
X_test_tr = data_2[test_to_keep]

train_columns_titles = ['Gene Description', 'Gene Accession Number', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10',
       '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25',
       '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38']

X_train_tr = X_train_tr.reindex(columns=train_columns_titles)

test_columns_titles = ['Gene Description', 'Gene Accession Number','39', '40', '41', '42', '43', '44', '45', '46',
       '47', '48', '49', '50', '51', '52', '53',  '54', '55', '56', '57', '58', '59',
       '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72']

X_test_tr = X_test_tr.reindex(columns=test_columns_titles)

X_train = X_train_tr.T
X_test = X_test_tr.T

X_train.columns = X_train.iloc[1]
X_train = X_train.drop(["Gene Description", "Gene Accession Number"]).apply(pd.to_numeric)
X_test.columns = X_test.iloc[1]
X_test = X_test.drop(["Gene Description", "Gene Accession Number"]).apply(pd.to_numeric)

X_train = X_train.reset_index(drop=True)
Y_train = Y[Y.patient <= 38].reset_index(drop=True)
X_test = X_test.reset_index(drop=True)
Y_test = Y[Y.patient > 38].reset_index(drop=True)

X_train_fl = X_train.astype(float, 64)
X_test_fl = X_test.astype(float, 64)


scaler = StandardScaler()
X_train_scl = scaler.fit_transform(X_train_fl)
X_test_scl = scaler.transform(X_test_fl)

Y_train = Y_train['cancer']
Y_test = Y_test['cancer']


def run_all_methods_analysis_real_data(X_train, Y_train, X_test, Y_test, n_components_list=[2], threshold=0.25):
    p = X_train.shape[1]
    Y_train = np.array(Y_train).flatten()
    Y_test = np.array(Y_test).flatten()

    results = {
        'n_components': n_components_list,
        'precision_PCA': [],
        'error_PCA': [],
        'accuracy_PCA': [],
        'non_zero_vars_PCA': [],
        'auc_PCA': [],
        'precision_LDA': [],
        'error_LDA': [],
        'accuracy_LDA': [],
        'non_zero_vars_LDA': [],
        'auc_LDA': [],
        'precision_HSIC': [],
        'error_HSIC': [],
        'accuracy_HSIC': [],
        'non_zero_vars_HSIC': [],
        'auc_HSIC': [],
        'precision_Bair': [],
        'error_Bair': [],
        'accuracy_Bair': [],
        'non_zero_vars_Bair': [],
        'auc_Bair': [],
        'precision_CSPCA': [],
        'error_CSPCA': [],
        'accuracy_CSPCA': [],
        'non_zero_vars_CSPCA': [],
        'auc_CSPCA': [],
        'precision_SCSPCA': [],
        'error_SCSPCA': [],
        'accuracy_SCSPCA': [],
        'non_zero_vars_SCSPCA': [],
        'auc_SCSPCA': [],
        'precision_SDSPCA': [],
        'error_SDSPCA': [],
        'accuracy_SDSPCA': [],
        'non_zero_vars_SDSPCA': [],
        'auc_SDSPCA': [],
        'precision_SPCA': [],
        'error_SPCA': [],
        'accuracy_SPCA': [],
        'non_zero_vars_SPCA': [],
        'auc_SPCA': [],
        'precision_SSPCA': [],
        'error_SSPCA': [],
        'accuracy_SSPCA': [],
        'non_zero_vars_SSPCA': [],
        'auc_SSPCA': []
    }

    eta_sparse_grid = [8000,8500,9000,9500,10000]  
    para_spca_grid = [[0.1, 0.1], [0.1,0.1], [0.5,0.5], [1,1]]  
    c_sspca_grid = [onp.sqrt(p)/32,onp.sqrt(p)/16,onp.sqrt(p)/8, onp.sqrt(p)/4, onp.sqrt(p)/2,]       

    
    X_train_main, X_val, Y_train_main, Y_val = train_test_split(
        X_train, Y_train, test_size=0.2, random_state=2002)

    scaler_X = StandardScaler()
    X_train_main = scaler_X.fit_transform(X_train_main)
    X_val = scaler_X.transform(X_val)
    X_test_scaled = scaler_X.transform(X_test)
    
    def count_nonzero_vars(W, threshold=1e-7):
        if W.ndim == 1:
            W = W.reshape(-1, 1)
        return onp.mean(onp.sum(onp.abs(W) > threshold, axis=0))

    for n_components in n_components_list:
        # PCA
        pca = PCA(n_components=n_components)
        X_train_pca = pca.fit_transform(X_train_main)
        X_test_pca = pca.transform(X_test_scaled)
        clf_pcr = LogisticRegression(solver='lbfgs', max_iter=1000)
        clf_pcr.fit(X_train_pca, Y_train_main)
        Y_pred = clf_pcr.predict(X_test_pca)
        Y_pred_proba = clf_pcr.predict_proba(X_test_pca)[:, 1]
        results['precision_PCA'].append(precision_score(Y_test, Y_pred, zero_division = 0))
        results['error_PCA'].append(1 - accuracy_score(Y_test, Y_pred))
        results['accuracy_PCA'].append(accuracy_score(Y_test, Y_pred))
        results['non_zero_vars_PCA'].append(p)
        results['auc_PCA'].append(roc_auc_score(Y_test, Y_pred_proba))
        
        # LDA
        n_comp_lda = min(n_components, len(np.unique(Y_train_main))-1, X_train_main.shape[1])
        lda = LinearDiscriminantAnalysis(n_components=n_comp_lda)
        X_train_lda = lda.fit_transform(X_train_main, Y_train_main)
        X_test_lda = lda.transform(X_test_scaled)
        Y_pred_lda = lda.predict(X_test_scaled)
        Y_pred_proba_lda = lda.predict_proba(X_test_scaled)[:, 1]
        results['precision_LDA'].append(precision_score(Y_test, Y_pred_lda, zero_division = 0))
        results['error_LDA'].append(1 - accuracy_score(Y_test, Y_pred_lda))
        results['accuracy_LDA'].append(accuracy_score(Y_test, Y_pred_lda))
        results['non_zero_vars_LDA'].append(p)
        results['auc_LDA'].append(roc_auc_score(Y_test,Y_pred_proba_lda))
        
        # SPCA using HSIC
        K = delta_kernel(Y_train_main)
        spca_result = spca_hsic(X_train_main, Y_train_main, K, n_components)
        W_hsic = spca_result['W']
        Z_test_hsic = X_test_scaled @ W_hsic
        clf_hsic = LogisticRegression(solver='lbfgs', max_iter=1000)
        clf_hsic.fit(X_train_main @ W_hsic, Y_train_main)
        Y_pred_hsic = clf_hsic.predict(Z_test_hsic)
        Y_pred_proba_hsic = clf_hsic.predict_proba(Z_test_hsic)[:, 1]
        results['precision_HSIC'].append(precision_score(Y_test, Y_pred_hsic, zero_division = 0))
        results['error_HSIC'].append(1 - accuracy_score(Y_test, Y_pred_hsic))
        results['accuracy_HSIC'].append(accuracy_score(Y_test, Y_pred_hsic))
        results['non_zero_vars_HSIC'].append(count_nonzero_vars(W_hsic))
        results['auc_HSIC'].append(roc_auc_score(Y_test,Y_pred_proba_hsic))

        # Bair's
        feature_scores = onp.abs(onp.corrcoef(X_train_main.T, Y_train_main.T)[:-1, -1])
        selected_features = feature_scores >= threshold
        X_train_selected = X_train_main[:, selected_features]
        X_test_selected = X_test_scaled[:, selected_features]
        pca_bair = PCA(n_components=min(n_components, X_train_selected.shape[1]))
        X_train_bair = pca_bair.fit_transform(X_train_selected)
        X_test_bair = pca_bair.transform(X_test_selected)
        clf_bair = LogisticRegression(solver='lbfgs', max_iter=1000)
        clf_bair.fit(X_train_bair, Y_train_main)
        Y_pred_bair = clf_bair.predict(X_test_bair)
        Y_pred_proba_bair = clf_bair.predict_proba(X_test_bair)[:, 1]
        results['precision_Bair'].append(precision_score(Y_test, Y_pred_bair, zero_division = 0))
        results['error_Bair'].append(1 - accuracy_score(Y_test, Y_pred_bair))
        results['accuracy_Bair'].append(accuracy_score(Y_test, Y_pred_bair))
        results['non_zero_vars_Bair'].append(onp.sum(selected_features))
        results['auc_Bair'].append(roc_auc_score(Y_test,Y_pred_proba_bair))

        # CSPCA
        lambda_grid = [0.01]
        best_lambda = lambda_grid[0]
        best_error = float('inf')
        for lambda_ in lambda_grid:
            spca_sup = cspca(X_train_main, Y_train_main, n_components, p=p, m=145, lambda_=lambda_)
            W_sup = spca_sup['W']
            Z_val_sup = X_val @ W_sup
            clf_sup = LogisticRegression(solver='lbfgs', max_iter=1000)
            clf_sup.fit(X_train_main @ W_sup, Y_train_main)
            Y_pred_sup = clf_sup.predict(Z_val_sup)
            current_error = 1 - accuracy_score(Y_val, Y_pred_sup)
            if current_error < best_error:
                best_error = current_error
                best_lambda = lambda_
        
        spca_sup = cspca(X_train_main, Y_train_main, n_components, p=p, m=145, lambda_=best_lambda)
        W_sup = spca_sup['W']
        Z_test_sup = X_test_scaled @ W_sup
        clf_sup = LogisticRegression(solver='lbfgs', max_iter=1000)
        clf_sup.fit(X_train_main @ W_sup, Y_train_main)
        Y_pred_sup = clf_sup.predict(Z_test_sup)
        Y_pred_proba_sup = clf_sup.predict_proba(Z_test_sup)[:, 1]
        results['precision_CSPCA'].append(precision_score(Y_test, Y_pred_sup, zero_division = 0))
        results['error_CSPCA'].append(1 - accuracy_score(Y_test, Y_pred_sup))
        results['accuracy_CSPCA'].append(accuracy_score(Y_test, Y_pred_sup))
        results['non_zero_vars_CSPCA'].append(count_nonzero_vars(W_sup))
        results['auc_CSPCA'].append(roc_auc_score(Y_test,Y_pred_proba_sup))
        
        # SCSPCA 
        best_eta_sparse = eta_sparse_grid[0]
        best_error = float('inf')
        for eta_sparse in eta_sparse_grid:
            kappa = 0.1
            epsilon = 1e-4
            n = Y_train_main.shape[0]
            K = delta_kernel(Y_train_main) + epsilon * np.eye(n)
            C = X_train_main.T @ K @ X_train_main + best_lambda * X_train_main.T @ X_train_main
            W_manpg, F_manpg, sparsity, time_manpg, iter_, flag_succ, num_linesearch, mean_ssn = manpg_orth_sparse(
                C, n_components, p, eta_sparse * onp.ones(p))
            X_val_proj = X_val @ W_manpg
            clf_sparse = LogisticRegression(solver='lbfgs', max_iter=1000)
            clf_sparse.fit(X_train_main @ W_manpg, Y_train_main)
            Y_pred_sparse = clf_sparse.predict(X_val_proj)
            current_error = 1 - accuracy_score(Y_val, Y_pred_sparse)
            if current_error < best_error:
                best_error = current_error
                best_eta_sparse = eta_sparse
        
        print(f"Selected eta_sparse: {best_eta_sparse}")
        C = X_train_main.T @ K @ X_train_main + kappa * X_train_main.T @ X_train_main
        W_manpg, F_manpg, sparsity, time_manpg, iter_, flag_succ, num_linesearch, mean_ssn = manpg_orth_sparse(
            C, n_components, p, best_eta_sparse * onp.ones(p))
        
        X_test_proj = X_test_scaled @ W_manpg
        clf_sparse = LogisticRegression(solver='lbfgs', max_iter=1000)
        clf_sparse.fit(X_train_main @ W_manpg, Y_train_main)
        Y_pred_sparse = clf_sparse.predict(X_test_proj)
        Y_pred_proba_sparse = clf_sparse.predict_proba(X_test_proj)[:, 1]
        results['precision_SCSPCA'].append(precision_score(Y_test, Y_pred_sparse, zero_division = 0))
        results['error_SCSPCA'].append(1 - accuracy_score(Y_test, Y_pred_sparse))
        results['accuracy_SCSPCA'].append(accuracy_score(Y_test, Y_pred_sparse))
        results['non_zero_vars_SCSPCA'].append(count_nonzero_vars(W_manpg))
        results['auc_SCSPCA'].append(roc_auc_score(Y_test,Y_pred_proba_sparse))

        # SDSPCA
        alpha_grid = [0.1,1,10,100,1000,10000,1000000,10000000]
        beta_grid = [0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001]

        
        best_alpha = alpha_grid[0]
        best_beta = beta_grid[0]
        best_error = float('inf')
        for alpha in alpha_grid:
            for beta in beta_grid:
                sdspca = SDSPCA(n_components=n_components, alpha=alpha, beta=beta)
                Q_train = sdspca.fit_transform(X_train_main, Y_train_main)
                Q_val = sdspca.transform(X_val)
                clf = LogisticRegression(solver='lbfgs', max_iter=1000)
                clf.fit(Q_train, Y_train_main)
                Y_pred = clf.predict(Q_val)
                current_error = 1 - accuracy_score(Y_val, Y_pred)
                if current_error < best_error:
                    best_error = current_error
                    best_alpha = alpha
                    best_beta = beta       

        print(f"Best SDSPCA params: alpha={best_alpha}, beta={best_beta}")
        sdspca = SDSPCA(n_components=n_components, alpha=best_alpha, beta=best_beta)
        Q_train = sdspca.fit_transform(X_train_main, Y_train_main)
        Q_test = sdspca.transform(X_test_scaled)
        clf_sdspca = LogisticRegression(solver='lbfgs', max_iter=1000)
        clf_sdspca.fit(Q_train, Y_train_main)
        Y_pred_sdspca = clf_sdspca.predict(Q_test)
        Y_pred_proba_sdspca = clf_sdspca.predict_proba(Q_test)[:, 1]
        print(sdspca.Q_)
        results['precision_SDSPCA'].append(precision_score(Y_test, Y_pred_sdspca, zero_division = 0))
        results['error_SDSPCA'].append(1 - accuracy_score(Y_test, Y_pred_sdspca))
        results['accuracy_SDSPCA'].append(accuracy_score(Y_test, Y_pred_sdspca))
        results['non_zero_vars_SDSPCA'].append(count_nonzero_vars(sdspca.Q_))
        results['auc_SDSPCA'].append(roc_auc_score(Y_test,Y_pred_proba_sdspca))


        # SPCA 
        best_para_spca = para_spca_grid[0]
        best_error = float('inf')
        for para_spca in para_spca_grid:
            spca_result = spca(X_train_main, K=n_components, 
                 para=para_spca, 
                 type_="predictor", sparse="penalty", lambda_=1e-4)
            W_spca = spca_result['loadings']
            Z_val_spca = X_val @ W_spca
            clf_spca = LogisticRegression(solver='lbfgs', max_iter=1000)
            clf_spca.fit(X_train_main @ W_spca, Y_train_main)
            Y_pred_spca = clf_spca.predict(Z_val_spca)
            current_error = 1 - accuracy_score(Y_val, Y_pred_spca)
            if current_error < best_error:
                best_error = current_error
                best_para_spca = para_spca

        print(f"Selected para_spca: {best_para_spca}")
        spca_result = spca(X_train_main, K=n_components, 
                         para=best_para_spca, 
                         type_="predictor", sparse="penalty", lambda_=1e-4)
        W_spca = spca_result['loadings']
        Z_test_spca = X_test_scaled @ W_spca
        clf_spca = LogisticRegression(solver='lbfgs', max_iter=1000)
        clf_spca.fit(X_train_main @ W_spca, Y_train_main)
        Y_pred_spca = clf_spca.predict(Z_test_spca)
        Y_pred_proba_spca = clf_spca.predict_proba(Z_test_spca)[:, 1]
        results['precision_SPCA'].append(precision_score(Y_test, Y_pred_spca, zero_division = 0))
        results['error_SPCA'].append(1 - accuracy_score(Y_test, Y_pred_spca))
        results['accuracy_SPCA'].append(accuracy_score(Y_test, Y_pred_spca))
        results['non_zero_vars_SPCA'].append(count_nonzero_vars(W_spca))
        results['auc_SPCA'].append(roc_auc_score(Y_test,Y_pred_proba_spca))

        # SSPCA
        best_c_sspca = c_sspca_grid[0]  
        best_error = float('inf')
        for c_sspca in c_sspca_grid:
            sspca_result = sspca(X_train_main, Y_train_main, K=n_components, c=c_sspca, 
                   X_test=X_val, Y_test=Y_val, kernel_type='delta')
            Z_val_sspca = sspca_result['Z_test']
            clf_sspca = LogisticRegression(solver='lbfgs', max_iter=1000)
            clf_sspca.fit(sspca_result['Z'], Y_train_main)
            Y_pred_sspca = clf_sspca.predict(Z_val_sspca)
            current_error = 1 - accuracy_score(Y_val, Y_pred_sspca)
            if current_error < best_error:
                best_error = current_error
                best_c_sspca = c_sspca   
        
        print(f"Selected c_sspca: {best_c_sspca}")
        sspca_result = sspca(X_train_main, Y_train_main, K=n_components, c=best_c_sspca, 
                           X_test=X_test_scaled, Y_test=Y_test, kernel_type='delta')
        Z_test_sspca = sspca_result['Z_test']
        W_sspca = sspca_result['V']
        clf_sspca = LogisticRegression(solver='lbfgs', max_iter=1000)
        clf_sspca.fit(sspca_result['Z'], Y_train_main)
        Y_pred_sspca = clf_sspca.predict(Z_test_sspca)
        Y_pred_proba_sspca = clf_sspca.predict_proba(Z_test_sspca)[:, 1]
        results['precision_SSPCA'].append(precision_score(Y_test, Y_pred_sspca, zero_division = 0))
        results['error_SSPCA'].append(1 - accuracy_score(Y_test, Y_pred_sspca))
        results['accuracy_SSPCA'].append(accuracy_score(Y_test, Y_pred_sspca))
        results['non_zero_vars_SSPCA'].append(count_nonzero_vars(W_sspca))
        results['auc_SSPCA'].append(roc_auc_score(Y_test,Y_pred_proba_sspca))
    
    final_results = []
    
    for i, n_components in enumerate(n_components_list):
        row = {'n_components': n_components}
        
        for method in ['PCR', 'LDA', 'HSIC', 'Bair' ,'CSPCA' , 'SCSPCA' , 'SDSPCA', 'SPCA', 'SSPCA']:
            row[f'precision_{method}'] = results[f'precision_{method}'][i]
            row[f'error_{method}'] = results[f'error_{method}'][i]
            row[f'accuracy_{method}'] = results[f'accuracy_{method}'][i]
            row[f'non_zero_vars_{method}'] = results[f'non_zero_vars_{method}'][i]
            row[f'auc_{method}'] = results[f'auc_{method}'][i]
        
        final_results.append(row)
    
    return pd.DataFrame(final_results)

def analyze_real_dataset(X_train, Y_train, X_test, Y_test, n_components_list=[2]):
    results_df = run_all_methods_analysis_real_data(X_train, Y_train, X_test, Y_test, 
                                                  n_components_list=n_components_list)
    
    print("\nLeukemia Dataset Analysis Results:")
    for method in ['PCR', 'LDA', 'HSIC', 'Bair', 'CSPCA', 'SCSPCA', 'SDSPCA', 'SPCA', 'SSPCA']:
        print(f"\nMethod: {method}")
        for n_comp in n_components_list:
            row = results_df[results_df['n_components'] == n_comp].iloc[0]
            print(f"  n_components = {n_comp}:")
            print(f"    Precision: {row[f'precision_{method}']:.4f}")
            print(f"    Classification Error: {row[f'error_{method}']:.4f}")
            print(f"    Accuracy: {row[f'accuracy_{method}']:.4f}")
            print(f"    Non-zero variables: {row[f'non_zero_vars_{method}']:.1f}")
            print(f"    AUC: {row[f'auc_{method}']:.1f}")
    
    return results_df

